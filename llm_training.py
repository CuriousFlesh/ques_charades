# -*- coding: utf-8 -*-
"""llm_training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cnLRhrW7OqhOlzpMmslQNCXInCJwCzHo
"""

pip install -q -U google-generativeai

# Commented out IPython magic to ensure Python compatibility.
# %env API_KEY='AIzaSyB8mL8iJoNr1tKpANIWlkE47ssv4z8kE-w'

import google.generativeai as genai
import os

genai.configure(api_key='AIzaSyB8mL8iJoNr1tKpANIWlkE47ssv4z8kE-w') # Changed API_KEY to 'API_KEY'

# Import necessary libraries
import google.generativeai as genai
import pandas as pd
import time
import threading
from tqdm import tqdm
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Set the file path within Google Drive
file_path = '/content/drive/MyDrive/1-1800.csv'

# Configure the API
genai.configure(api_key='AIzaSyB8mL8iJoNr1tKpANIWlkE47ssv4z8kE-w')

# Load the dataset
df = pd.read_csv('new_data.csv')  # Ensure the CSV is located in Google Drive

# Reformulated questions
questions_reformulated = [
    "Is the movie primarily a love story or romance?",
    "Does the plot revolve around family dynamics or drama?",
    "Is there a significant element of friendship in the movie?",
    "Is the movie set in a rural village?",
    "Is there a major focus on social or political issues?",
    "Does the movie feature a strong female lead character?",
    "Is the protagonist seeking revenge as part of the story?",
    "Is there a supernatural or fantasy element in the plot?",
    "Is the movie set during a historical period?",
    "Does the plot involve a wedding or marriage as a central theme?",
    "Is there a significant action or crime-related element in the movie?",
    "Is the movie a biopic or based on true events?",
    "Does the film involve a journey or travel as part of the story?",
    "Is the movie known for its music or significant song sequences?",
    "Does the movie take place in a metropolitan city or urban setting?"
]

# Instantiate the Gemini model
model = genai.GenerativeModel("gemini-1.5-flash")

# Function to check if movie data already exists in the CSV
def movie_exists(title):
    try:
        existing_data = pd.read_csv(file_path, engine='python')
        return title in existing_data['Title'].values
    except FileNotFoundError:
        return False

# Function to generate responses for a single movie
def ask_movie_questions_single_request(movie, event):
    title = movie['title']
    genre = movie['genre']
    plot = movie['plot']

    # Combine all questions into a single prompt
    prompt = (
        f"Movie Title: {title}\n"
        f"Genre: {genre}\n"
        f"Plot: {plot}\n\n"
        "Please answer the following yes/no questions in the format:\n"
        "1. **Answer** (Explanation)\n"
        "2. **Answer** (Explanation)\n"
        "...\n\n"
        "Answer the following yes/no questions. If the answer cannot be determined, say 'no':\n\n"
    )
    prompt += "\n".join([f"{idx + 1}. {question}" for idx, question in enumerate(questions_reformulated)])

    # Send the single request
    try:
        response = model.generate_content(prompt)
        if event.is_set():
            return

        answers = []
        if response and response.candidates:
            response_text = response.candidates[0].content.parts[0].text.strip()
            for line in response_text.split("\n"):
                if line.strip():
                    if len(line.split("**")[0]) > 5:
                        continue
                    answer = line.split("**")[1].strip()
                    if answer == 'Possibly':
                        answer = 'Yes'
                    answers.append(answer)
            while len(answers) < len(questions_reformulated):
                answers.append('no')
        else:
            answers = ['no'] * len(questions_reformulated)
    except Exception as e:
        print(f"Error occurred while generating response for '{title}': {e}")
        answers = ['no'] * len(questions_reformulated)

    # Return the movie data with responses
    return pd.DataFrame([{'Title': title, 'Genre': genre, 'Plot': plot, **dict(zip(questions_reformulated, answers))}])

# Function to append movie data to the CSV file
def append_to_csv(data):
    data.to_csv(file_path, mode='a', header=not pd.io.common.file_exists(file_path), index=False)

# Function to process each movie with a timeout
def process_movie_with_timeout(index):
    movie = df.iloc[index]
    title = movie['title']

    if movie_exists(title):
        return  # Skip if the movie data already exists

    event = threading.Event()  # Create an event to signal if the request should be terminated

    def target():
        nonlocal event
        movie_data = ask_movie_questions_single_request(movie, event)
        if movie_data is not None:
            append_to_csv(movie_data)  # Save immediately after processing
        else:
            print(f"Skipped '{movie['title']}' due to timeout.")

    thread = threading.Thread(target=target)
    thread.start()

    # Wait for the thread to complete or timeout
    thread.join(timeout=30)  # Wait up to 30 seconds

    if thread.is_alive():
        print(f"Terminating request for '{movie['title']}' due to timeout.")
        event.set()  # Signal the thread to terminate
        thread.join()  # Wait for the thread to finish

    time.sleep(4)  # Sleep for 5 seconds after each request

# Initialize the CSV file if it doesn't exist, preserving existing data
if not pd.io.common.file_exists(file_path):
    results_df = pd.DataFrame(columns=['Title', 'Genre', 'Plot'] + questions_reformulated)
    results_df.to_csv(file_path, index=False)  # Create the CSV file

# Process each movie
for i in tqdm(range(len(df)), desc="Processing Movies"):
    process_movie_with_timeout(i)

print(f"Updated CSV file saved as '{file_path}'")